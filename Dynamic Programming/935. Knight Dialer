There one more Approach that solves in O(logn) using Matrix multiplication and some observation.

# Approach 1
T.c -> O(n) , S.c -> O(1)

class Solution {
public:
    int knightDialer(int n) {
        int mod = 1000000007;
        map<int,vector<int>> moves;
        vector<long long int> prev(10);
        vector<long long int> curr(10);
        
        moves[0] = {4,6};
        moves[1] = {6,8};
        moves[2] = {7,9};
        moves[3] = {4,8};
        moves[4] = {0,3,9};
        moves[5] = {};
        moves[6] = {0,1,7};
        moves[7] = {2,6};
        moves[8] = {1,3};
        moves[9] = {2,4};

        for(int i = 0; i < 10; i++) prev[i] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 0; j < 10; j++){
                curr[j] = 0;
                for(auto it : moves[j]) curr[j] = (curr[j] + prev[it])%mod;
            }
            prev = curr;
        }

        long long int ans = 0;
        for(int i = 0; i < 10; i++) ans = (ans + prev[i])%mod;
        return ans;
    }
};

# Approach 2 
T.c -> O(n) , S.c -> O(n)

class Solution {
public:
    int knightDialer(int n) {
        int mod = 1000000007;
        map<int,vector<int>> moves;
        vector<vector<long long int>> dp(n+1,vector<long long int>(10));
        
        moves[0] = {4,6};
        moves[1] = {6,8};
        moves[2] = {7,9};
        moves[3] = {4,8};
        moves[4] = {0,3,9};
        moves[5] = {};
        moves[6] = {0,1,7};
        moves[7] = {2,6};
        moves[8] = {1,3};
        moves[9] = {2,4};

        for(int i = 0; i < 10; i++) dp[1][i] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 0; j < 10; j++){
                for(auto it : moves[j]) dp[i][j] = (dp[i][j] + dp[i-1][it])%mod;
            }
        }

        long long int ans = 0;
        for(int i = 0; i < 10; i++) ans = (ans + dp[n][i])%mod;
        return ans;
    }
};
